# MSD v1 Comprehensive Testing Configuration
# Tests all implemented features with comprehensive data and debug visualization

cb-lcars-msd-v1-comprehensive:
  variables:
    card:
      height: 70vw
      color:
        background:
          default: black

  # NEW MSD v1 STRUCTURE - msd at root level
  msd:
    version: 1

    # Add explicit debug configuration to test config-based debug control
    debug:
      enabled: true
      overlays:
        anchors: true
        bounding_boxes: true
        routing: true
        performance: true
      console:
        verbose: true
        timing: true
      hud:
        auto_show: true

    base_svg:
      source: builtin:ncc-1701-a-blue

    view_box: auto

    # FIXED: Test anchor system - use actual coordinates for percentage anchors
    anchors:
      debug_anchor_1: [300, 200]
      debug_anchor_2: [600, 300]
      debug_anchor_3: [480, 600]    # FIXED: 25% of 1920 = 480, 50% of 1200 = 600
      debug_anchor_4: [1440, 300]   # FIXED: 75% of 1920 = 1440, 25% of 1200 = 300
      performance_test: [100, 100]

    # Test data source system
    data_sources:
      test_cpu_temp:
        entity: sensor.bathroom_dial_battery
        window_seconds: 3600
        minEmitMs: 200
        coalesceMs: 100
        maxDelayMs: 500
        emitOnSameValue: false
        history:
          preload: true  # FIXED: Re-enable preload now that entities are pre-loaded
          hours: 2
      test_memory:
        entity: sensor.bedroom_dial_battery
        window_seconds: 1800
        minEmitMs: 500
        history:
          preload: true  # FIXED: Re-enable preload now that entities are pre-loaded

    # Test palette system
    palettes:
      test_palette:
        primary: "var(--lcars-orange)"
        secondary: "var(--lcars-yellow)"
        accent: "var(--lcars-cyan)"

    # FIXED: Test overlays - use valid anchor references only
    overlays:
      # Text overlays
      - id: title_overlay
        type: text
        position: [50, 50]
        style:
          value: "MSD v1 COMPREHENSIVE TEST"
          color: var(--picard-orange)
          font_size: 28
          font_weight: bold

      - id: status_text
        type: text
        position: debug_anchor_1
        style:
          value: "Phase Testing"
          color: var(--lcars-cyan)
          font_size: 16

      # Sparkline overlays with data sources
      - id: cpu_sparkline
        type: sparkline
        position: [100, 150]
        size: [400, 80]
        source: test_cpu_temp
        style:
          color: var(--lcars-yellow)
          width: 2
          markers:
            r: 3
            fill: var(--lcars-yellow)
          label_last:
            decimals: 1
            format: "{v}%"
            offset: [10, -5]
            fill: var(--lcars-orange)

      - id: memory_sparkline
        type: sparkline
        position: [100, 280]
        size: [400, 80]
        source: test_memory
        style:
          color: var(--lcars-cyan)
          width: 2

      # FIXED: Line overlays using only defined anchors (not overlay IDs)
      - id: test_line_1
        type: line
        anchor: debug_anchor_1
        attach_to: debug_anchor_2  # CHANGED: Use defined anchor instead of overlay
        route: auto
        style:
          color: var(--lcars-orange)
          width: 4
          corner_style: round
          corner_radius: 16

      - id: test_line_2
        type: line
        anchor: debug_anchor_2
        attach_to: debug_anchor_3  # CHANGED: Use defined anchor instead of overlay
        route: auto
        style:
          color: var(--lcars-blue)
          width: 3
          corner_style: round
          corner_radius: 12

      - id: test_line_3
        type: line
        anchor: debug_anchor_3
        attach_to: debug_anchor_4
        route: auto
        style:
          color: var(--lcars-purple)
          width: 2

      # FIXED: Test percentage anchors with actual coordinates
      - id: percentage_test
        type: text
        position: debug_anchor_3
        style:
          value: "25% Anchor (480,600)"
          color: var(--lcars-purple)
          font_size: 14

      - id: percentage_test_2
        type: text
        position: debug_anchor_4
        style:
          value: "75% Anchor (1440,300)"
          color: var(--lcars-purple)
          font_size: 14

    # Test rules system
    rules:
      - id: cpu_hot_test
        priority: 10
        when:
          all:
            - entity: sensor.bathroom_dial_battery  # FIXED: Use actual entity
              above: 70
        apply:
          overlays:
            - id: cpu_sparkline
              style:
                color: var(--lcars-red)
            - id: test_line_1
              style:
                color: var(--lcars-red)
                width: 6

  styles:
    custom_fields:
      msd_svg_base:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 0
      msd_svg_overlays:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 1
      msd_controls:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 2
      msd_debug:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 100


  custom_fields:
    msd_svg_base: |
      [[[
        // Access MSD config from root level
        const msdConfig = this._config?.msd || this.config?.msd;

        console.group('[MSD v1 Comprehensive Test Debug]');
        console.log('Raw config anchors:', msdConfig.anchors);
        console.log('Debug config:', msdConfig.debug);

        let svgContent = window.cblcars.getSvgContent(msdConfig.base_svg.source);
        if (!svgContent) return `<div style="color:orange;">Loading MSD v1 SVG...</div>`;

        const viewBox = window.cblcars.getSvgViewBox(svgContent);
        const aspect = window.cblcars.getSvgAspectRatio(viewBox);

        // Process anchors with better SVG extraction and logging
        const svgAnchors = window.cblcars.findSvgAnchors(svgContent) || {};
        const userAnchors = msdConfig.anchors || {};

        console.log('Raw SVG anchors found:', Object.keys(svgAnchors).length);
        console.log('User config anchors:', Object.keys(userAnchors));

        const resolvedAnchors = {};
        const [minX, minY, vw, vh] = viewBox;

        // First, add all SVG anchors
        for (const [name, pos] of Object.entries(svgAnchors)) {
          resolvedAnchors[name] = pos;
        }

        // Then process and add user anchors (with percentage resolution)
        for (const [name, pos] of Object.entries(userAnchors)) {
          if (Array.isArray(pos) && pos.length === 2) {
            let [x, y] = pos;
            if (typeof x === 'string' && x.endsWith('%')) {
              x = minX + (parseFloat(x) / 100) * vw;
            }
            if (typeof y === 'string' && y.endsWith('%')) {
              y = minY + (parseFloat(y) / 100) * vh;
            }
            resolvedAnchors[name] = [Number(x), Number(y)];
          } else {
            resolvedAnchors[name] = pos;
          }
        }

        // Store resolved anchors globally so pipeline can access them
        this._msdViewBox = viewBox;
        this._msdAnchors = resolvedAnchors;
        window._msdTestAnchors = resolvedAnchors;

        console.log('Final resolved anchors:', Object.keys(resolvedAnchors).length);
        console.groupEnd();

        return `<div id="msd-v1-comprehensive-wrapper" style="width:100%;height:100%;border:2px solid cyan;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
      ]]]

    msd_svg_overlays: |
      [[[
        console.log('[MSD v1 Comprehensive] Overlay field evaluated - letting pipeline handle rendering');
        return '<!-- MSD v1 Pipeline Will Handle Overlay Rendering -->';
      ]]]

    msd_controls: |
      [[[
        try {
          if (!this._msdV1ComprehensiveBoot) {
            // Check if MSD v1 system is loaded
            if (typeof window.__msdDebug === 'undefined') {
              console.error('[MSD v1 Comprehensive] window.__msdDebug not found');
              return `<div style="color:red;padding:10px;">MSD v1 system not loaded</div>`;
            }

            if (!window.__msdDebug.initMsdPipeline) {
              console.error('[MSD v1 Comprehensive] initMsdPipeline not found');
              return `<div style="color:red;padding:10px;">initMsdPipeline not available</div>`;
            }

            this._msdV1ComprehensiveBoot = true;
            const msdConfig = this._config?.msd || this.config?.msd;
            const baseWrapper = this.shadowRoot.getElementById('msd-v1-comprehensive-wrapper');
            const mount = baseWrapper || this.shadowRoot;
            const realHass = this.___hass || hass;

            // Use pre-processed anchors for comprehensive test
            const enhancedConfig = { ...msdConfig };
            if (window._msdTestAnchors && Object.keys(window._msdTestAnchors).length > 5) {
              console.log('[MSD v1 Comprehensive] Using pre-processed anchors:', Object.keys(window._msdTestAnchors).length);
              enhancedConfig.anchors = window._msdTestAnchors;
            }

            console.log('[MSD v1 Comprehensive] Initializing pipeline with debug config:', enhancedConfig.debug);

            window.__msdDebug.initMsdPipeline(enhancedConfig, mount, realHass).then(pipeline => {
              const resolvedModel = pipeline.getResolvedModel?.();
              const pipelineAnchors = resolvedModel?.anchors || {};

              const stats = {
                enabled: pipeline.enabled,
                overlayCount: resolvedModel?.overlays?.length || 0,
                anchorCount: Object.keys(pipelineAnchors).length,
                dataSourceCount: Object.keys(msdConfig.data_sources || {}).length,
                ruleCount: (msdConfig.rules || []).length,
                errors: pipeline.errors?.length || 0
              };

              console.group('[MSD v1 Comprehensive] Pipeline Started Successfully');
              console.table(stats);

              if (pipeline.errors?.length) {
                console.error('Pipeline Errors:', pipeline.errors);
              } else {
                console.log('✅ All systems operational');
              }
              console.groupEnd();

              // Verify debug system integration
              setTimeout(() => {
                console.log('[MSD v1 Comprehensive] Testing debug system...');

                const debugStatus = window.__msdDebug?.debug?.status?.();
                if (debugStatus) {
                  console.log('Debug Status:', debugStatus);

                  // Test debug rendering
                  if (window.__msdDebug.debug.render) {
                    console.log('🔧 Testing debug render...');
                    window.__msdDebug.debug.render(this.shadowRoot, resolvedModel?.viewBox, {
                      anchors: resolvedModel?.anchors,
                      overlays: resolvedModel?.overlays
                    });
                  }
                }

                // Show available console commands
                console.group('[MSD v1 Debug] Available Console Commands:');
                console.log('🎯 window.__msdDebug.debug.anchors.show() - Show anchor markers');
                console.log('📦 window.__msdDebug.debug.bounding.show() - Show bounding boxes');
                console.log('🛣️  window.__msdDebug.debug.routing.show() - Show routing guides');
                console.log('⚡ window.__msdDebug.debug.performance.show() - Show performance overlay');
                console.log('🔄 window.__msdDebug.debug.refresh() - Refresh debug overlays');
                console.log('📊 window.__msdDebug.debug.status() - Show debug status');
                console.groupEnd();
              }, 1000);

            }).catch(err => {
              console.error('[MSD v1 Comprehensive] Pipeline init failed:', err);
            });
          }

        } catch(e) {
          console.error('[MSD v1 Comprehensive] Bootstrap failed:', e);
          return `<div style="color:red;padding:10px;">Bootstrap failed: ${e.message}</div>`;
        }

        const vb = this._msdViewBox || [0,0,1920,1200];
        const aspect = window.cblcars.getSvgAspectRatio(vb);
        return `<div style="width:100%;height:100%;aspect-ratio:${aspect};pointer-events:none;"></div>`;
      ]]]



  custom_fields2:
    msd_svg_base: |
      [[[

        // Access MSD config from root level
        const msdConfig = this._config?.msd || this.config?.msd;

        console.group('[MSD v1 Comprehensive Test Debug]');
        console.log('Raw config anchors:', msdConfig.anchors);
        console.log('Debug config:', msdConfig.debug);

        let svgContent = window.cblcars.getSvgContent(msdConfig.base_svg.source);
        if (!svgContent) return `<div style="color:orange;">Loading MSD v1 SVG...</div>`;

        const viewBox = window.cblcars.getSvgViewBox(svgContent);
        const aspect = window.cblcars.getSvgAspectRatio(viewBox);

        // ENHANCED: Process anchors with better SVG extraction and logging
        const svgAnchors = window.cblcars.findSvgAnchors(svgContent) || {};
        const userAnchors = msdConfig.anchors || {};

        console.log('Raw SVG anchors found:', Object.keys(svgAnchors).length);
        console.log('Raw SVG anchor names:', Object.keys(svgAnchors));
        console.log('User config anchors:', Object.keys(userAnchors));

        const resolvedAnchors = {};
        const [minX, minY, vw, vh] = viewBox;

        // First, add all SVG anchors
        for (const [name, pos] of Object.entries(svgAnchors)) {
          resolvedAnchors[name] = pos;
        }

        // Then process and add user anchors (with percentage resolution)
        for (const [name, pos] of Object.entries(userAnchors)) {
          if (Array.isArray(pos) && pos.length === 2) {
            let [x, y] = pos;

            if (typeof x === 'string' && x.endsWith('%')) {
              x = minX + (parseFloat(x) / 100) * vw;
            }
            if (typeof y === 'string' && y.endsWith('%')) {
              y = minY + (parseFloat(y) / 100) * vh;
            }

            resolvedAnchors[name] = [Number(x), Number(y)];
          } else {
            resolvedAnchors[name] = pos;
          }
        }

        // IMPORTANT: Store resolved anchors globally so pipeline can access them
        this._msdViewBox = viewBox;
        this._msdAnchors = resolvedAnchors;

        // ADDED: Also store on window for pipeline access
        window._msdTestAnchors = resolvedAnchors;

        console.log('Final resolved anchors:', Object.keys(resolvedAnchors).length);
        console.log('Final anchor names:', Object.keys(resolvedAnchors));
        console.log('SVG anchors contributed:', Object.keys(svgAnchors).length);
        console.log('User anchors contributed:', Object.keys(userAnchors).length);

        // Check for the mystery anchors
        const mysteryAnchors = Object.keys(resolvedAnchors).filter(name =>
          !Object.keys(svgAnchors).includes(name) &&
          !Object.keys(userAnchors).includes(name)
        );
        if (mysteryAnchors.length > 0) {
          console.warn('Mystery anchors found (not from SVG or config):', mysteryAnchors);
        }

        console.groupEnd();

        return `<div id="msd-v1-comprehensive-wrapper" style="width:100%;height:100%;border:2px solid cyan;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
      ]]]

    msd_svg_overlays: |
      [[[
        // MSD v1 handles overlay rendering automatically once pipeline initializes
        // No need to check for pipeline availability here - just let it handle rendering
        console.log('[MSD v1 Comprehensive] Overlay field evaluated - letting pipeline handle rendering');
        return '<!-- MSD v1 Pipeline Will Handle Overlay Rendering -->';
      ]]]

    msd_controls: |
      [[[
        try {
          if (!this._msdV1ComprehensiveBoot) {
            // Check if MSD v1 system is loaded
            if (typeof window.__msdDebug === 'undefined') {
              console.error('[MSD v1 Comprehensive] window.__msdDebug not found');
              return `<div style="color:red;padding:10px;">MSD v1 system not loaded</div>`;
            }

            if (!window.__msdDebug.initMsdPipeline) {
              console.error('[MSD v1 Comprehensive] initMsdPipeline not found');
              return `<div style="color:red;padding:10px;">initMsdPipeline not available</div>`;
            }

            this._msdV1ComprehensiveBoot = true;
            const msdConfig = this._config?.msd || this.config?.msd;
            const baseWrapper = this.shadowRoot.getElementById('msd-v1-comprehensive-wrapper');
            const mount = baseWrapper || this.shadowRoot;
            const realHass = this.___hass || hass;

            // SIMPLIFIED: Use pre-processed anchors for comprehensive test
            const enhancedConfig = { ...msdConfig };
            if (window._msdTestAnchors && Object.keys(window._msdTestAnchors).length > 5) {
              console.log('[MSD v1 Comprehensive] Using pre-processed anchors:', Object.keys(window._msdTestAnchors).length);
              enhancedConfig.anchors = window._msdTestAnchors;
            }

            console.log('[MSD v1 Comprehensive] Initializing pipeline with debug config:', enhancedConfig.debug);

            window.__msdDebug.initMsdPipeline(enhancedConfig, mount, realHass).then(pipeline => {
              const resolvedModel = pipeline.getResolvedModel?.();
              const pipelineAnchors = resolvedModel?.anchors || {};

              const stats = {
                enabled: pipeline.enabled,
                overlayCount: resolvedModel?.overlays?.length || 0,
                anchorCount: Object.keys(pipelineAnchors).length,
                dataSourceCount: Object.keys(msdConfig.data_sources || {}).length,
                ruleCount: (msdConfig.rules || []).length,
                errors: pipeline.errors?.length || 0
              };

              console.group('[MSD v1 Comprehensive] Pipeline Started Successfully');
              console.table(stats);

              // SIMPLIFIED: Basic anchor verification
              const configAnchors = Object.keys(msdConfig.anchors || {}).length;
              const svgAnchors = Object.keys(window._msdTestAnchors || {}).length - configAnchors;
              const routingAnchors = Object.keys(pipelineAnchors).length - Object.keys(window._msdTestAnchors || {}).length;

              console.log(`📊 Anchor Summary: ${configAnchors} config + ${svgAnchors} SVG + ${routingAnchors} routing = ${Object.keys(pipelineAnchors).length} total`);

              if (pipeline.errors?.length) {
                console.error('Pipeline Errors:', pipeline.errors);
              } else {
                console.log('✅ All systems operational');
              }
              console.groupEnd();

              // ENHANCED: Better HUD initialization with explicit config checking
              setTimeout(() => {
                const debugConfig = enhancedConfig.debug || {};
                console.log('[MSD v1 Comprehensive] Debug config for HUD:', debugConfig);

                if (debugConfig.hud?.auto_show) {
                  console.log('[MSD v1 Comprehensive] Attempting to show HUD based on config...');
                  if (window.__msdDebug.hud?.show) {
                    window.__msdDebug.hud.show();
                    console.log('[MSD v1 Comprehensive] ✅ HUD show() called');
                  } else {
                    console.warn('[MSD v1 Comprehensive] ⚠️ HUD.show() not available');
                  }
                } else {
                  console.log('[MSD v1 Comprehensive] HUD auto_show disabled by config');
                }
              }, 1500);

              // Check consolidated pipeline access
              setTimeout(() => {
                console.log('[MSD v1 Comprehensive] Verifying consolidated interface...');

                const pipelineInstance = window.__msdDebug.pipelineInstance;
                const dsManager = pipelineInstance?.dataSourceManager ||
                                pipelineInstance?.systemsManager?.dataSourceManager ||
                                window.__msdDebug.dataSourceManager;

                if (dsManager) {
                  const entityIds = dsManager.listIds();
                  console.log(`✅ DataSourceManager: ${entityIds.length} entities available`);

                  if (entityIds.length > 0) {
                    // Test rules with consolidated access
                    const rulesEngine = pipelineInstance?.rulesEngine;
                    if (rulesEngine) {
                      console.log('✅ Rules engine operational via consolidated interface');
                      try {
                        const getEntity = (id) => dsManager?.getEntity(id);
                        const rulesResult = rulesEngine.evaluateDirty({ getEntity });
                        console.log(`📊 Rules: ${rulesResult.overlayPatches?.length || 0} patches, ${rulesResult.profilesAdd?.length || 0} profiles`);
                      } catch (error) {
                        console.warn('⚠️ Rules evaluation failed:', error.message);
                      }
                    }
                  }
                } else {
                  console.warn('⚠️ DataSourceManager not found via consolidated interface');
                }
              }, 2000);

            }).catch(err => {
              console.error('[MSD v1 Comprehensive] Pipeline init failed:', err);
            });
          }

          // ENHANCED: Debug rendering with better config checking and logging
          setTimeout(() => {
            try {
              const msdConfig = this._config?.msd || this.config?.msd;
              const debugConfig = msdConfig?.debug || {};

              console.log('[MSD v1 Comprehensive] Debug rendering check:', {
                enabled: debugConfig.enabled,
                overlays: debugConfig.overlays,
                debugRenderAvailable: !!window.__msdDebug?.debug?.render
              });

              if (window.__msdDebug?.debug?.render) {
                // Pass the full debug config to the renderer
                window.__msdDebug.debug.render(this.shadowRoot, this._msdViewBox, {
                  anchors: this._msdAnchors,
                  debugConfig: debugConfig // Pass the config explicitly
                });
                console.log('[MSD v1 Comprehensive] ✅ Debug render called with config');
              } else {
                console.warn('[MSD v1 Comprehensive] ⚠️ Debug render not available');
              }
            } catch(e) {
              console.warn('[MSD v1 Comprehensive] Debug rendering failed:', e);
            }
          }, 800);

        } catch(e) {
          console.error('[MSD v1 Comprehensive] Bootstrap failed:', e);
          return `<div style="color:red;padding:10px;">Bootstrap failed: ${e.message}</div>`;
        }

        const vb = this._msdViewBox || [0,0,1920,1200];
        const aspect = window.cblcars.getSvgAspectRatio(vb);
        return `<div style="width:100%;height:100%;aspect-ratio:${aspect};pointer-events:none;"></div>`;
      ]]]
