# MSD v1 vs Legacy Side-by-Side Testing Configuration
# Tests both implementations with identical configurations to validate feature parity

cb-lcars-msd-legacy:
  variables:
    card:
      height: 35vw
      color:
        background:
          default: black
    msd:
      # LEGACY IMPLEMENTATION - Force old code path
      debug:
        geometry: true
        overlay: true
        perf: true
        level: debug
      base_svg: builtin:ncc-1701-a-blue
      anchors:
        test_anchor_1: [200, 150]
        test_anchor_2: [400, 300]
        test_anchor_3: ["50%", "25%"]
      data_sources:
        cpu_temp:
          entity: sensor.cpu_temp
          window_seconds: 3600
      overlays:
        - type: text
          id: legacy_title
          position: [50, 50]
          style:
            value: "LEGACY MSD"
            color: var(--lcars-red)
            font_size: 24
        - type: sparkline
          id: legacy_sparkline
          position: [50, 100]
          size: [300, 80]
          source: cpu_temp
          style:
            color: var(--lcars-yellow)
            width: 2
        - type: line
          id: legacy_line
          anchor: test_anchor_1
          attach_to: legacy_sparkline
          route: auto
          style:
            color: var(--lcars-orange)
            width: 3

  styles:
    custom_fields:
      msd_svg_base: { width: 100%, height: 100%, position: absolute, top: 0, left: 0, z-index: 0 }
      msd_svg_overlays: { width: 100%, height: 100%, position: absolute, top: 0, left: 0, z-index: 1 }

  custom_fields:
    msd_svg_base: |
      [[[
        // FORCE LEGACY PATH - Disable MSD v1
        window.CBLCARS_MSD_V1_ENABLE = false;

        let svgContent = window.cblcars.getSvgContent(variables.msd.base_svg);
        if (!svgContent) return `<div>Loading Legacy SVG...</div>`;

        const viewBox = window.cblcars.getSvgViewBox(svgContent);
        const aspect = window.cblcars.getSvgAspectRatio(viewBox);

        // Store for legacy renderer
        variables.msd._viewBox = viewBox;
        variables.msd._anchors = { ...window.cblcars.findSvgAnchors(svgContent), ...variables.msd.anchors };

        return `<div id="legacy-msd-wrapper" style="width:100%;height:100%;border:2px solid red;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
      ]]]

    msd_svg_overlays: |
      [[[
        // Legacy overlay rendering (existing cb-lcars implementation)
        const overlays = variables.msd.overlays || [];
        const { svgMarkup } = window.cblcars.renderMsdOverlay({
          overlays,
          anchors: variables.msd._anchors,
          hass,
          root: this.shadowRoot,
          viewBox: variables.msd._viewBox,
          dataSources: variables.msd.data_sources || {}
        });

        return svgMarkup;
      ]]]

---

cb-lcars-msd-v1:
  variables:
    card:
      height: 35vw
      color:
        background:
          default: black

  # NEW MSD v1 STRUCTURE - msd at root level
  msd:
    version: 1
    # NEW MSD v1 IMPLEMENTATION - Force new code path
    base_svg:
      source: builtin:ncc-1701-a-blue
    anchors:
      test_anchor_1: [200, 150]
      test_anchor_2: [400, 300]
      test_anchor_3: ["50%", "25%"]
    data_sources:
      cpu_temp:
        entity: sensor.cpu_temp
        window_seconds: 3600
        minEmitMs: 250
        coalesceMs: 120
    overlays:
      - id: v1_title
        type: text
        position: [50, 50]
        style:
          value: "MSD v1"
          color: var(--lcars-green)
          font_size: 24
      - id: v1_sparkline
        type: sparkline
        position: [50, 100]
        size: [300, 80]
        source: cpu_temp
        style:
          color: var(--lcars-cyan)
          width: 2
          markers: { r: 2, fill: var(--lcars-cyan) }
      - id: v1_line
        type: line
        anchor: test_anchor_1
        attach_to: v1_sparkline
        route: auto
        style:
          color: var(--lcars-blue)
          width: 3
          corner_style: round
          corner_radius: 12

  styles:
    custom_fields:
      msd_svg_base: { width: 100%, height: 100%, position: absolute, top: 0, left: 0, z-index: 0 }
      msd_svg_overlays: { width: 100%, height: 100%, position: absolute, top: 0, left: 0, z-index: 1 }
      msd_controls: { width: 100%, height: 100%, position: absolute, top: 0, left: 0, z-index: 2 }



  custom_fields:
    msd_svg_base: |
      [[[
        // FIXED: Enable comprehensive debugging and force MSD v1
        window.CBLCARS_MSD_V1_ENABLE = true;
        window.cblcars = window.cblcars || {};
        window.cblcars._debugFlags = {
          overlay: true,
          connectors: true,
          geometry: true,
          perf: true,
          validation: true
        };

        // Access MSD config from root level
        const msdConfig = this._config?.msd || this.config?.msd;

        // FIXED: Add debug logging for percentage resolution
        console.group('[MSD v1 Comprehensive Test Debug]');
        console.log('Raw config anchors:', msdConfig.anchors);

        let svgContent = window.cblcars.getSvgContent(msdConfig.base_svg.source);
        if (!svgContent) return `<div style="color:orange;">Loading MSD v1 SVG...</div>`;

        const viewBox = window.cblcars.getSvgViewBox(svgContent);
        const aspect = window.cblcars.getSvgAspectRatio(viewBox);

        // FIXED: Proper anchor resolution including percentages
        const svgAnchors = window.cblcars.findSvgAnchors(svgContent) || {};
        const userAnchors = msdConfig.anchors || {};

        // Process user anchors to resolve percentages
        const resolvedAnchors = {};
        const [minX, minY, vw, vh] = viewBox;

        for (const [name, pos] of Object.entries(userAnchors)) {
          if (Array.isArray(pos) && pos.length === 2) {
            let [x, y] = pos;

            // Resolve percentage coordinates
            if (typeof x === 'string' && x.endsWith('%')) {
              x = minX + (parseFloat(x) / 100) * vw;
            }
            if (typeof y === 'string' && y.endsWith('%')) {
              y = minY + (parseFloat(y) / 100) * vh;
            }

            resolvedAnchors[name] = [Number(x), Number(y)];
          } else {
            resolvedAnchors[name] = pos;
          }
        }

        this._msdViewBox = viewBox;
        this._msdAnchors = { ...svgAnchors, ...resolvedAnchors };

        // Log resolved anchors
        console.log('ViewBox:', viewBox);
        console.log('SVG Anchors:', Object.keys(svgAnchors).length);
        console.log('Resolved User Anchors:', resolvedAnchors);
        console.log('Final Anchor Count:', Object.keys(this._msdAnchors).length);
        console.log('Data Sources:', Object.keys(msdConfig.data_sources || {}));
        console.log('Overlays:', (msdConfig.overlays || []).length);
        console.groupEnd();

        return `<div id="msd-v1-comprehensive-wrapper" style="width:100%;height:100%;border:2px solid cyan;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
      ]]]
    msd_svg_overlays: |
      [[[
        // FIXED: Don't check pipeline instance - let the pipeline handle its own rendering
        // The AdvancedRenderer will automatically inject overlays when pipeline initializes

        const msdConfig = this._config?.msd || this.config?.msd;

        // If MSD v1 pipeline is available, return minimal markup and let it handle rendering
        if (window.__msdDebug?.initMsdPipeline) {
          console.log('[MSD v1 Comprehensive] MSD v1 pipeline available - letting AdvancedRenderer handle overlays');

          // Return empty - the AdvancedRenderer injects directly into SVG
          return '<!-- MSD v1 Pipeline Handles Overlay Rendering -->';
        }

        // Fallback to legacy renderer only if MSD v1 not available
        console.warn('[MSD v1 Comprehensive] MSD v1 pipeline not available - using legacy renderer');

        const overlays = msdConfig.overlays || [];
        const { svgMarkup } = window.cblcars.renderMsdOverlay({
          overlays,
          anchors: this._msdAnchors,
          hass,
          root: this.shadowRoot,
          viewBox: this._msdViewBox,
          dataSources: msdConfig.data_sources || {}
        });

        return svgMarkup;
      ]]]
    msd_controls: |
      [[[
        // FIXED: MSD v1 pipeline initialization with better error handling
        try {
          if (!this._msdV1ComprehensiveBoot) {

            // Check if MSD v1 system is loaded
            if (typeof window.__msdDebug === 'undefined') {
              console.error('[MSD v1 Comprehensive] window.__msdDebug not found - MSD v1 system not loaded');
              return `<div style="color:red;padding:10px;">MSD v1 system not loaded. Check if src/msd/* files are imported in main bundle.</div>`;
            }

            if (!window.__msdDebug.initMsdPipeline) {
              console.error('[MSD v1 Comprehensive] initMsdPipeline not found');
              console.log('[MSD v1 Comprehensive] Available methods:', Object.keys(window.__msdDebug));
              return `<div style="color:red;padding:10px;">initMsdPipeline not available. Available: ${Object.keys(window.__msdDebug).join(', ')}</div>`;
            }

            this._msdV1ComprehensiveBoot = true;
            const msdConfig = this._config?.msd || this.config?.msd;
            const baseWrapper = this.shadowRoot.getElementById('msd-v1-comprehensive-wrapper');
            const mount = baseWrapper || this.shadowRoot;

            console.log('[MSD v1 Comprehensive] Initializing pipeline with config:', msdConfig);
            console.log('[MSD v1 Comprehensive] Mount element:', mount.id || mount.className || 'shadowRoot');

            window.__msdDebug.initMsdPipeline(msdConfig, mount, hass).then(p => {
              window.__msdDebug.pipelineInstance = p;

              const stats = {
                enabled: p.enabled,
                overlayCount: p.getResolvedModel?.()?.overlays?.length || 0,
                anchorCount: Object.keys(p.getResolvedModel?.()?.anchors || {}).length,
                dataSourceCount: Object.keys(msdConfig.data_sources || {}).length,
                ruleCount: (msdConfig.rules || []).length,
                errors: p.errors?.length || 0
              };

              console.group('[MSD v1 Comprehensive] Pipeline Started');
              console.table(stats);

              if (p.errors?.length) {
                console.error('Pipeline Errors:', p.errors);
              } else {
                console.log('✅ Pipeline started successfully');
              }

              // Log resolved model for debugging
              const resolvedModel = p.getResolvedModel?.();
              if (resolvedModel) {
                console.log('Resolved Anchors:', Object.keys(resolvedModel.anchors || {}));
                console.log('Resolved Overlays:', (resolvedModel.overlays || []).map(o => o.id));
              }

              console.groupEnd();



              // FIXED: Force HASS entity ingestion after pipeline is ready
              setTimeout(() => {
                try {
                  const realHass = this.___hass || hass;
                  if (realHass?.states && Object.keys(realHass.states).length > 0) {
                    console.log('[MSD v1 Comprehensive] Force ingesting HASS entities:', Object.keys(realHass.states).length);

                    // Use the working manual ingestion method
                    if (window.__msdDebug?.entities?.ingest) {
                      window.__msdDebug.entities.ingest(realHass.states);
                      console.log('[MSD v1 Comprehensive] HASS entities ingested via debug API');
                    } else if (p?.ingestHass) {
                      p.ingestHass(realHass);
                      console.log('[MSD v1 Comprehensive] HASS entities ingested via pipeline');
                    }

                    // Verify ingestion worked
                    const entityCount = window.__msdDebug?.entities?.list?.()?.length || 0;
                    console.log('[MSD v1 Comprehensive] Entity count after ingestion:', entityCount);
                  }
                } catch(e) {
                  console.warn('[MSD v1 Comprehensive] HASS ingestion failed:', e);
                }
              }, 1500); // Give pipeline time to fully initialize



              // Show HUD after pipeline starts
              setTimeout(() => {
                if (window.__msdDebug?.hud?.show) {
                  window.__msdDebug.hud.show();
                  console.log('[MSD v1 Comprehensive] HUD activated');
                }
              }, 2000); // Show HUD after entity ingestion

            }).catch(err => {
              console.error('[MSD v1 Comprehensive] Pipeline init failed:', err);
              console.log('[MSD v1 Comprehensive] Error details:', err.stack || err.message || err);
            });
          }

          // Enable debug rendering after short delay
          setTimeout(() => {
            try {
              if (window.__msdDebug?.debug?.render) {
                window.__msdDebug.debug.render(this.shadowRoot, this._msdViewBox, {
                  anchors: this._msdAnchors
                });
                console.log('[MSD v1 Comprehensive] Debug rendering enabled');
              }
            } catch(e) {
              console.warn('[MSD v1 Comprehensive] Debug rendering failed:', e);
            }
          }, 500);

        } catch(e) {
          console.error('[MSD v1 Comprehensive] Bootstrap failed:', e);
          return `<div style="color:red;padding:10px;">Bootstrap failed: ${e.message}</div>`;
        }

        const vb = this._msdViewBox || [0,0,1920,1200];
        const aspect = window.cblcars.getSvgAspectRatio(vb);
        return `<div style="width:100%;height:100%;aspect-ratio:${aspect};pointer-events:none;"></div>`;
      ]]]
