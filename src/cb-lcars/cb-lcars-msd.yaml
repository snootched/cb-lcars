cb-lcars-msd:
  variables:
    card:
      height: 70vw
      color:
        background:
          default: black
    msd:
      debug:
        geometry: true
        connectors: true
        overlay: true
        perf: true
        validation: true
        level: debug
      base_svg: builtin:ncc-1701-a-blue
      anchors:
        smart_clear_anchor:
          - 200
          - 200
        smart_far_anchor:
          - 200
          - 320
        smart_blocked_anchor:
          - 200
          - 500
        smart_forced_xy_anchor:
          - 200
          - 650
        grid_forced_anchor:
          - 200
          - 830
        manhattan_anchor:
          - 200
          - 960
      data_sources: {}
      overlays:
        - type: ribbon
          id: target_box
          position:
            - 1500
            - 460
          size:
            - 260
            - 200
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 18
          off_color: rgba(255,255,255,0.08)
          on_color: rgba(255,255,120,0.25)
        - type: ribbon
          id: obstacle_vertical
          position:
            - 700
            - 120
          size:
            - 120
            - 820
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 12
          off_color: rgba(255,128,0,0.10)
          on_color: rgba(255,128,0,0.18)
        - type: ribbon
          id: obstacle_mid
          position:
            - 900
            - 420
          size:
            - 180
            - 180
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 10
          off_color: rgba(180,0,255,0.10)
          on_color: rgba(180,0,255,0.18)
        - type: ribbon
          id: obstacle_far
          position:
            - 1100
            - 780
          size:
            - 220
            - 180
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 10
          off_color: rgba(0,180,255,0.10)
          on_color: rgba(0,180,255,0.18)
        - type: line
          id: line_smart_clear
          anchor: smart_clear_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          stroke: var(--lcars-yellow)
          width: 10
          corner_style: round
          corner_radius: 40
        - type: line
          id: line_smart_far_avoid
          anchor: smart_far_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          avoid:
            - obstacle_far
          stroke: var(--lcars-teal)
          width: 10
          corner_style: round
          corner_radius: 40
        - type: line
          id: line_smart_blocked
          anchor: smart_blocked_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          avoid:
            - obstacle_mid
          smart_proximity: 24
          stroke: var(--lcars-orange)
          width: 12
          corner_style: round
          corner_radius: 46
        - type: line
          id: line_smart_forced_xy
          anchor: smart_forced_xy_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          route_mode: xy
          avoid:
            - obstacle_vertical
          smart_proximity: 24
          stroke: var(--lcars-purple)
          width: 12
          corner_style: round
          corner_radius: 46
        - type: line
          id: line_grid_forced
          anchor: grid_forced_anchor
          attach_to: target_box
          route: auto
          route_mode_full: grid
          avoid:
            - obstacle_vertical
            - obstacle_mid
          stroke: var(--lcars-blue)
          width: 12
          corner_style: round
          corner_radius: 50
        - type: line
          id: line_manhattan_baseline
          anchor: manhattan_anchor
          attach_to: target_box
          route: auto
          stroke: var(--lcars-green)
          width: 10
          corner_style: round
          corner_radius: 40
  styles:
    custom_fields:
      msd_svg_base:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 0
      msd_svg_overlays:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 1
        - pointer-events: auto
      msd_controls:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 2
        - pointer-events: none
  custom_fields:
    msd_svg_base: |
      [[[
        let svgContent = window.cblcars.getSvgContent(variables.msd.base_svg);
        if (!svgContent) {
          return `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:gray;">Loading SVG...</div>`;
        }
        const viewBox = window.cblcars.getSvgViewBox(svgContent);
        const svgAnchors = window.cblcars.findSvgAnchors(svgContent) || {};
        const userAnchors = variables.msd.anchors || {};
        const anchorTable = { ...svgAnchors, ...userAnchors };

        // Persist for renderers
        variables.msd._viewBox = viewBox;
        variables.msd._anchors = anchorTable;

        // Expose anchors on ShadowRoot so debug/introspection can see them
        try { this.shadowRoot.__cblcars_anchors = anchorTable; } catch (_) {}

        const aspect = window.cblcars.getSvgAspectRatio(viewBox);
        // Keep: base wrapper defines the truth box for SVG
        return `<div id="cblcars-msd-wrapper" style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
      ]]]
    msd_svg_overlays: |
      [[[
        const timelines = variables.msd?.timelines || {};
        const overlays = variables.msd.overlays || [];

        const { svgMarkup, animationsToRun } = window.cblcars.renderMsdOverlay({
          overlays,
          anchors: variables.msd._anchors,
          styleLayers: variables.msd.presets,
          hass,
          root: this.shadowRoot,
          viewBox: variables.msd._viewBox,
          timelines,
          animations: variables.msd.animations,
          dataSources: variables.msd.data_sources || {}
        });

        const overlayConfigsById = Array.isArray(overlays)
          ? overlays.reduce((acc, o) => { if (o && o.id) acc[o.id] = o; return acc; }, {})
          : {};

        // Persist for introspection/highlight helpers
        try {
          this.shadowRoot.__cblcars_overlayConfigsById = overlayConfigsById;
          this.shadowRoot.__cblcars_anchors = variables.msd._anchors;
        } catch (_) {}

        if (!this.__cblcars_postStamp) {
          this.__cblcars_postStamp = true;
          requestAnimationFrame(() => {
            this.__cblcars_postStamp = false;

            /* Run overlay-level animations (anime.js v4 scopes) */
            try {
              if (Array.isArray(animationsToRun) && animationsToRun.length > 0) {
                animationsToRun.forEach(anim => this._animationScope.animate(anim, this.hass));
              }
            } catch (_) {}

            /* Rebuild timelines (double-rAF already satisfied upstream in createTimelines) */
            try {
              if (timelines && Object.keys(timelines).length > 0 && typeof this._rebuildTimelines === 'function') {
                this._rebuildTimelines(timelines, overlayConfigsById, variables.msd.presets || {});
              }
            } catch (_) {}

            /* Mount controls (HTML card overlays) */
            try {
              const controls = overlays.filter(o => o && o.type === 'control');
              if (controls.length && window.cblcars.renderMsdControls) {
                window.cblcars.renderMsdControls({
                  overlays: controls,
                  viewBox: variables.msd._viewBox,
                  anchors: variables.msd._anchors,
                  root: this.shadowRoot,
                  hass,
                  hostId: 'cblcars-controls-layer',
                  hostParentSelector: '#msd_controls',
                  measureSelector: '#cblcars-msd-wrapper'
                });
              }
            } catch (_) {}

            /* Initial connector layout */
            try {
              window.cblcars.connectors.invalidate && window.cblcars.connectors.invalidate('*');
              window.cblcars.overlayHelpers?.layoutPendingConnectors?.(this.shadowRoot, variables.msd._viewBox);
            } catch (_) {}
            setTimeout(() => {
              window.cblcars.connectors.invalidate && window.cblcars.connectors.invalidate('*');
              window.cblcars.overlayHelpers?.layoutPendingConnectors?.(this.shadowRoot, variables.msd._viewBox);
            }, 120);

            /* Safety delayed debug renders (covers late-applied flags) */
            try {
              const redrawIfFlags = () => {
                if (window.cblcars?._debugFlags?.overlay ||
                    window.cblcars?._debugFlags?.connectors ||
                    window.cblcars?._debugFlags?.perf ||
                    window.cblcars?._debugFlags?.geometry) {
                  window.cblcars.debug?.render?.(this.shadowRoot, variables.msd._viewBox, { anchors: variables.msd._anchors });
                }
              };
              setTimeout(redrawIfFlags, 60);
              setTimeout(redrawIfFlags, 350);
            } catch (_) {}
          });
        }

        return svgMarkup;
      ]]]
    msd_controls: |
      [[[
        // Mirror the base wrapper's aspect-locked box in the controls field
        const vb = variables.msd?._viewBox || [0,0,1920,1200];
        const aspect = window.cblcars.getSvgAspectRatio(vb);
        return `
          <div id="cblcars-controls-wrapper"
              style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;position:relative;aspect-ratio:${aspect};pointer-events:none;">
            <div id="cblcars-controls-box" style="position:relative;width:100%;height:100%;pointer-events:none;"></div>
          </div>`;
      ]]]
