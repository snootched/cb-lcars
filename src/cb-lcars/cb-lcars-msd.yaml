cb-lcars-msd:
  variables:
    card:
      height: 70vw
      color:
        background:
          default: black
    msd:
      debug:
        geometry: true
        connectors: true
        overlay: true
        perf: true
        validation: true
        level: debug
      base_svg: builtin:ncc-1701-a-blue
      anchors:
        smart_clear_anchor:
          - 200
          - 200
        smart_far_anchor:
          - 200
          - 320
        smart_blocked_anchor:
          - 200
          - 500
        smart_forced_xy_anchor:
          - 200
          - 650
        grid_forced_anchor:
          - 200
          - 830
        manhattan_anchor:
          - 200
          - 960
      data_sources: {}


      routing:
        channels:
          - id: main_bus
            rect: [400, 200, 800, 120]   # x,y,w,h in viewBox units
            weight: 0.6
          - id: aux_bus
            rect: [400, 600, 800, 120]
            weight: 0.7

      overlays:
        - type: ribbon
          id: target_box
          position:
            - 1500
            - 460
          size:
            - 260
            - 200
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 18
          off_color: rgba(255,255,255,0.08)
          on_color: rgba(255,255,120,0.25)
        - type: ribbon
          id: obstacle_vertical
          position:
            - 700
            - 120
          size:
            - 120
            - 820
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 12
          off_color: rgba(255,128,0,0.10)
          on_color: rgba(255,128,0,0.18)
        - type: ribbon
          id: obstacle_mid
          position:
            - 900
            - 420
          size:
            - 180
            - 180
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 10
          off_color: rgba(180,0,255,0.10)
          on_color: rgba(180,0,255,0.18)
        - type: ribbon
          id: obstacle_far
          position:
            - 1100
            - 780
          size:
            - 220
            - 180
          source: binary_sensor.any_motion
          threshold: 0.5
          rx: 10
          off_color: rgba(0,180,255,0.10)
          on_color: rgba(0,180,255,0.18)
        - type: line
          id: line_smart_clear
          anchor: smart_clear_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          stroke: var(--lcars-yellow)
          width: 10
          corner_style: round
          corner_radius: 40
        - type: line
          id: line_smart_far_avoid
          anchor: smart_far_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          avoid:
            - obstacle_far
          stroke: var(--lcars-teal)
          width: 10
          corner_style: round
          corner_radius: 40
        - type: line
          id: line_smart_blocked
          anchor: smart_blocked_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          avoid:
            - obstacle_mid
          smart_proximity: 24
          stroke: var(--lcars-orange)
          width: 12
          corner_style: round
          corner_radius: 46
        - type: line
          id: line_smart_forced_xy
          anchor: smart_forced_xy_anchor
          attach_to: target_box
          route: auto
          route_mode_full: smart
          route_mode: xy
          avoid:
            - obstacle_vertical
          smart_proximity: 24
          stroke: var(--lcars-purple)
          width: 12
          corner_style: round
          corner_radius: 46
        - type: line
          id: line_grid_forced
          anchor: grid_forced_anchor
          attach_to: target_box
          route: auto
          route_mode_full: grid
          avoid:
            - obstacle_vertical
            - obstacle_mid
          stroke: var(--lcars-blue)
          width: 12
          corner_style: round
          corner_radius: 120
          smoothing_mode: chaikin          # M5.6 demo
          smoothing_iterations: 2
        - type: line
          id: line_manhattan_baseline
          anchor: manhattan_anchor
          attach_to: target_box
          route: auto
          stroke: var(--lcars-green)
          width: 10
          corner_style: round
          corner_radius: 40

        - type: line
          id: line_channel_demo
          anchor: smart_far_anchor
          attach_to: target_box
          route: auto
          route_mode_full: grid
          route_channels:
            - main_bus
          route_channel_mode: prefer
          avoid:
            - obstacle_mid
          stroke: var(--lcars-pink)
          width: 12
          corner_style: round
          corner_radius: 40


  msd:
    version: 1
    use_packs:
      builtin: [core]
    base_svg:
      source: builtin:ncc-1701-a-blue
    anchors:
      smart_clear_anchor: [200, 200]
      smart_far_anchor: [200, 320]
      smart_blocked_anchor: [200, 500]
      smart_forced_xy_anchor: [200, 650]
      grid_forced_anchor: [200, 830]
      manhattan_anchor: [200, 960]
      target_box: [1500, 460]     # replaces legacy ribbon target_box as attach point
      cpu_test_anchor: [300, 180]
    routing:
      channels:
        - id: main_bus
          rect: [400, 200, 800, 120]
          weight: 0.6
        - id: aux_bus
          rect: [400, 600, 800, 120]
          weight: 0.7
    overlays:
      - id: line_smart_clear
        type: line
        anchor: smart_clear_anchor
        attach_to: target_box
        route: auto
        route_mode_full: smart
        style:
          color: var(--lcars-yellow)
          width: 10
          corner_style: round
          corner_radius: 40
      - id: line_smart_far_avoid
        type: line
        anchor: smart_far_anchor
        attach_to: target_box
        route: auto
        route_mode_full: smart
        avoid: [obstacle_far]
        style:
          color: var(--lcars-teal)
          width: 10
          corner_style: round
          corner_radius: 40
      - id: line_smart_blocked
        type: line
        anchor: smart_blocked_anchor
        attach_to: target_box
        route: auto
        route_mode_full: smart
        avoid: [obstacle_mid]
        style:
          color: var(--lcars-orange)
          width: 12
          corner_style: round
          corner_radius: 46
      - id: line_smart_forced_xy
        type: line
        anchor: smart_forced_xy_anchor
        attach_to: target_box
        route: auto
        route_mode_full: smart
        route_mode: xy
        avoid: [obstacle_vertical]
        style:
          color: var(--lcars-purple)
          width: 12
          corner_style: round
          corner_radius: 46
      - id: line_grid_forced
        type: line
        anchor: grid_forced_anchor
        attach_to: target_box
        route: auto
        route_mode_full: grid
        avoid: [obstacle_vertical, obstacle_mid]
        style:
          color: var(--lcars-blue)
          width: 12
          corner_style: round
          corner_radius: 120   # M5.5: intentionally large to demonstrate clamp vs short segments
          smoothing_mode: chaikin          # M5.6 demo
          smoothing_iterations: 2
      - id: line_manhattan_baseline
        type: line
        anchor: manhattan_anchor
        attach_to: target_box
        route: auto
        style:
          color: var(--lcars-green)
          width: 10
          corner_style: round
          corner_radius: 40
      - id: line_channel_demo
        type: line
        anchor: smart_far_anchor
        attach_to: target_box
        route: auto
        route_mode_full: grid
        route_channels: [main_bus]
        route_channel_mode: prefer
        avoid: [obstacle_mid]
        style:
          color: var(--lcars-pink)
          width: 12
          corner_style: round
          corner_radius: 40
      - id: cpu_temp_bar
        type: line
        anchor: cpu_test_anchor
        attach_to: target_box
        route: auto
        style:
          color: var(--lcars-orange)
          width:
            value_map:
              entity: sensor.bathroom_dial_battery
              input: [20, 90]
              output: [20, 30]
              clamp: true
              round: 0
              default: 22   # NEW: fallback before entity present / on failure
          corner_style: round
          corner_radius: 30
    rules:
      - id: cpu_hot
        priority: 10
        when:
          all:
            - entity: sensor.cpu_temp         # same entity
              above: 70
        apply:
          overlays:
            - id: cpu_temp_bar
              style: { color: var(--lcars-red) }
    animations: []       # (optional: add later)
    timelines: []        # (optional: add later)
    profiles: []         # (optional: add later)
    active_profiles: []  # (optional)
    hud:
      workbench:
        show_rule_badges: false


  styles:
    custom_fields:
      msd_svg_base:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 0
      msd_svg_overlays:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 1
        - pointer-events: auto
      msd_controls:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 2
        - pointer-events: none
      msd_hud_layer:
        - width: 100%
        - height: 100%
        - position: absolute
        - top: 0
        - left: 0
        - z-index: 1000
        - pointer-events: none
  custom_fields:
    msd_svg_base: |
      [[[
        let svgContent = window.cblcars.getSvgContent(variables.msd.base_svg);
        if (!svgContent) {
          return `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:gray;">Loading SVG...</div>`;
        }
        const viewBox = window.cblcars.getSvgViewBox(svgContent);
        const svgAnchors = window.cblcars.findSvgAnchors(svgContent) || {};
        const userAnchors = variables.msd.anchors || {};
        const anchorTable = { ...svgAnchors, ...userAnchors };

        // Persist for renderers
        variables.msd._viewBox = viewBox;
        variables.msd._anchors = anchorTable;

        // Expose anchors on ShadowRoot so debug/introspection can see them
        try { this.shadowRoot.__cblcars_anchors = anchorTable; } catch (_) {}

        const aspect = window.cblcars.getSvgAspectRatio(viewBox);
        // Keep: base wrapper defines the truth box for SVG
        return `<div id="cblcars-msd-wrapper" style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
      ]]]
    msd_svg_overlays: |
      [[[
        const timelines = variables.msd?.timelines || {};
        const overlays = variables.msd.overlays || [];

        const { svgMarkup, animationsToRun } = window.cblcars.renderMsdOverlay({
          overlays,
          anchors: variables.msd._anchors,
          styleLayers: variables.msd.presets,
          hass,
          root: this.shadowRoot,
          viewBox: variables.msd._viewBox,
          timelines,
          animations: variables.msd.animations,
          dataSources: variables.msd.data_sources || {}
        });

        const overlayConfigsById = Array.isArray(overlays)
          ? overlays.reduce((acc, o) => { if (o && o.id) acc[o.id] = o; return acc; }, {})
          : {};

        // Persist for introspection/highlight helpers
        try {
          this.shadowRoot.__cblcars_overlayConfigsById = overlayConfigsById;
          this.shadowRoot.__cblcars_anchors = variables.msd._anchors;
        } catch (_) {}

        if (!this.__cblcars_postStamp) {
          this.__cblcars_postStamp = true;
          requestAnimationFrame(() => {
            this.__cblcars_postStamp = false;

            /* Run overlay-level animations (anime.js v4 scopes) */
            try {
              if (Array.isArray(animationsToRun) && animationsToRun.length > 0) {
                animationsToRun.forEach(anim => this._animationScope.animate(anim, this.hass));
              }
            } catch (_) {}

            /* Rebuild timelines (double-rAF already satisfied upstream in createTimelines) */
            try {
              if (timelines && Object.keys(timelines).length > 0 && typeof this._rebuildTimelines === 'function') {
                this._rebuildTimelines(timelines, overlayConfigsById, variables.msd.presets || {});
              }
            } catch (_) {}

            /* Mount controls (HTML card overlays) */
            try {
              const controls = overlays.filter(o => o && o.type === 'control');
              if (controls.length && window.cblcars.renderMsdControls) {
                window.cblcars.renderMsdControls({
                  overlays: controls,
                  viewBox: variables.msd._viewBox,
                  anchors: variables.msd._anchors,
                  root: this.shadowRoot,
                  hass,
                  hostId: 'cblcars-controls-layer',
                  hostParentSelector: '#msd_controls',
                  measureSelector: '#cblcars-msd-wrapper'
                });
              }
            } catch (_) {}

            /* Initial connector layout */
            try {
              window.cblcars.connectors.invalidate && window.cblcars.connectors.invalidate('*');
              window.cblcars.overlayHelpers?.layoutPendingConnectors?.(this.shadowRoot, variables.msd._viewBox);
            } catch (_) {}
            setTimeout(() => {
              window.cblcars.connectors.invalidate && window.cblcars.connectors.invalidate('*');
              window.cblcars.overlayHelpers?.layoutPendingConnectors?.(this.shadowRoot, variables.msd._viewBox);
            }, 120);

            /* Safety delayed debug renders (covers late-applied flags) */
            try {
              const redrawIfFlags = () => {
                if (window.cblcars?._debugFlags?.overlay ||
                    window.cblcars?._debugFlags?.connectors ||
                    window.cblcars?._debugFlags?.perf ||
                    window.cblcars?._debugFlags?.geometry) {
                  window.cblcars.debug?.render?.(this.shadowRoot, variables.msd._viewBox, { anchors: variables.msd._anchors });
                }
              };
              setTimeout(redrawIfFlags, 60);
              setTimeout(redrawIfFlags, 350);
            } catch (_) {}
          });
        }

        return svgMarkup;
      ]]]
    msd_controls: |
      [[[
        // MSD v1 bootstrap (non-destructive). Runs once; leaves legacy rendering intact.
        try {
          // Diagnostics
          if (typeof window.__msdDebug === 'undefined') {
            console.warn('[MSD v1] window.__msdDebug not present. Did you import src/msd/autoRegister.js in your main bundle?');
          } else if (!window.__msdDebug.initMsdPipeline) {
            console.warn('[MSD v1] __msdDebug present but initMsdPipeline missing (check feature flag MSD_V1_ENABLE and import order).');
          }

          // Proceed only if feature flag code loaded
          if (!this._msdV1Boot &&
              window.__msdDebug?.initMsdPipeline &&
              (this._config?.msd || this.config?.msd)) {

            // Optional: verify feature flag (attached inside module)
            if (window.__msdDebug?.featureFlags && window.__msdDebug.featureFlags.MSD_V1_ENABLE === false) {
              console.warn('[MSD v1] Feature flag currently false; pipeline not started.');
            }

            this._msdV1Boot = true;
            const msdConfig = this._config?.msd || this.config?.msd;
            const baseWrapper = this.shadowRoot.getElementById('cblcars-msd-wrapper');
            const controlsBox = this.shadowRoot.getElementById('cblcars-controls-box');
            const mount = baseWrapper || controlsBox || this.shadowRoot;
            window.__msdDebug.initMsdPipeline(msdConfig, mount).then(p => {
              window.__msdDebug.pipelineInstance = p;
              let overlayCount = 0;
              try { overlayCount = p.getResolvedModel ? (p.getResolvedModel()?.overlays?.length || 0) : 0; } catch(_) {}
              if (p.enabled === false) {
                console.error('[MSD v1] pipeline disabled (validation errors):', p.errors);
              } else {
                console.info('[MSD v1] pipeline started: overlays=', overlayCount, 'mount=', mount.id || mount.className || 'shadowRoot');
              }
            }).catch(err => {
              console.error('[MSD v1] init failed', err);
            });
          }
          // Feed live hass states into pipeline each stamp if available
          try {
            const p = window.__msdDebug?.pipelineInstance;
            if (p?.enabled && p?.ingestHass && hass) p.ingestHass(hass);
          } catch(_) {}
        } catch(e) {
          console.warn('[MSD v1 bootstrap failed]', e);
        }
        // Mirror the base wrapper's aspect-locked box in the controls field (legacy content)
        const vb = variables.msd?._viewBox || [0,0,1920,1200];
        const aspect = window.cblcars.getSvgAspectRatio(vb);
        return `
          <div id="cblcars-controls-wrapper"
              style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;position:relative;aspect-ratio:${aspect};pointer-events:none;">
            <div id="cblcars-controls-box" style="position:relative;width:100%;height:100%;pointer-events:none;"></div>
          </div>`;
      ]]]
  msd_hud_layer: |
    [[[
      // Empty high z-index layer reserved for dev HUD or future overlays
      // pointer-events: none here; HUD panel itself sets pointer-events:auto
      return `<div id="cblcars-hud-layer" style="position:relative;width:100%;height:100%;pointer-events:none;"></div>`;
    ]]]

