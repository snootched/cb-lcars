type: custom:cb-lcars-base-card
variables:
  msd:
    base_svg: 'builtin:ncc-1701-a-blue'
    presets:
      state_resolver:
        enabled: true
        states:
          - entity: input_number.num_test
            from: 0
            to: 10
            preset: default
          - entity: input_number.num_test
            from: 10
            to: 1000
            preset: warning
      warning:
        text:
          color: var(--lcars-red)
          value: "[[[ return `WARNING: ${entity.state}` ]]]"
        line:
          color: var(--lcars-red)
          stroke_dasharray: "2,8"
          animation:
            type: march
            duration: 500
      default:
        text:
          font_size: 18
          font_family: Antonio
          align: center
          color:
            default: var(--primary-text-color)
        line:
          width: 4
          color:
            default: var(--lcars-orange)
          stroke_dasharray: "10,5"
          animation:
            type: march
            duration: 2000
    slots:
      test_callout:
        callout:
          entity: input_number.num_test
          anchor: warp_core
          preset: default
          visible: true
          text:
            value: "Test Callout"
            position: warp_core_label
            animation:
              type: blink
              duration: 1200
          line:
            width: 4
            color:
              default: var(--lcars-orange)
            stroke_dasharray: "10,5"
            animation:
              type: march
              duration: 2000
      test_smooth_line:
        callout:
          text:
            value: "Smooth Polyline"
            position: [50, 150]
            color:
              default: var(--lcars-blue)
          line:
            points:
              - [150, 150]
              - [200, 100]
              - [250, 150]
            rounded: true
            smooth_tension: 0.7
            width: 3
            color:
              default: var(--lcars-blue)
      test_draw_line:
        callout:
          text:
            value: "Draw Animation"
            position: [50, 180]
            color:
              default: var(--lcars-red)
          line:
            points:
              - [150, 180]
              - [250, 180]
            width: 3
            color:
              default: var(--lcars-red)
            animation:
              type: draw
              duration: 3000
      test_reverse_march:
        callout:
          text:
            value: "Reverse March"
            position: [50, 210]
            color:
              default: var(--lcars-golden-tanoi)
          line:
            points:
              - [150, 210]
              - [250, 210]
            width: 3
            color:
              default: var(--lcars-golden-tanoi)
            stroke_dasharray: "5,10"
            animation:
              type: march
              duration: 1500
              direction: reverse
      test_blink_line:
        callout:
          text:
            value: "Blinking Line"
            position: [50, 240]
            color:
              default: var(--lcars-lilac)
          line:
            points:
              - [150, 240]
              - [250, 240]
            width: 3
            color:
              default: var(--lcars-lilac)
            animation:
              type: blink
              duration: 1200ms
              min_opacity: 0.5
              max_opacity: 0.9
      test_motion_path:
        callout:
          text:
            value: "Motion Path"
            position: [50, 270]
          line:
            points:
              - [150, 270]
              - [200, 240]
              - [250, 270]
            width: 2
            color:
              default: var(--lcars-gray)
            # This animation will create and move a tracer along the line
            animation:
              type: motionpath
              duration: 4000
              loop: true
              tracer:
                shape: circle
                r: 5
                fill: var(--lcars-red)
      morph_target:
        callout:
          # This callout defines the shape we will morph TO.
          # It is made invisible so only the animation is seen.
          id: morph_target # This gives the line a predictable ID: msd_line_morph_target
          line:
            points:
              - [50, 300]
              - [150, 350]
              - [250, 300]
            width: 3
            color: transparent # Make the target path invisible
      morph_source:
        callout:
          # This is the line that will perform the morph animation.
          text:
            value: "Morph Animation"
            position: [50, 290]
          line:
            points:
              - [50, 325]
              - [250, 325] # A straight horizontal line
            width: 3
            color:
              default: var(--lcars-teal)
            animation:
              type: morph
              # The selector points to the ID of the target line.
              morph_to_selector: '#msd_line_morph_target'
              duration: 2500
              loop: true
              direction: alternate
custom_fields:
  msd_svg_base: |
    [[[
      // Use the same logic as your main msd_svg_base field
      let svgContent = '';
      let viewBox = [0, 0, 400, 200];
      let anchorTable = {};
      let svgKey = null;


      if (variables.msd.base_svg && variables.msd.base_svg.startsWith('builtin:')) {
        svgKey = variables.msd.base_svg.replace('builtin:', '');
      } else if (variables.msd.base_svg && variables.msd.base_svg.startsWith('/local/')) {
        svgKey = variables.msd.base_svg.split('/').pop().replace('.svg','');
      }

      svgContent = svgKey && window.cblcars?.msd?.svg_templates?.[svgKey];
      if (!svgContent) {
        return `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:gray;">Loading SVG...</div>`;
      }
      const match = svgContent.match(/viewBox="([0-9.\-]+)\s+([0-9.\-]+)\s+([0-9.\-]+)\s+([0-9.\-]+)"/);
      if (match) {
        viewBox = [parseFloat(match[1]), parseFloat(match[2]), parseFloat(match[3]), parseFloat(match[4])];
      }
      // Extract anchors from SVG: <circle id="..."/> and <text id="..."/>
      anchorTable = {};
      if (svgContent) {
        const anchorRegex = /<circle[^>]*\sid="([^"]+)"[^>]*\scx="([^"]+)"[^>]*\scy="([^"]+)"[^>]*>/g;
        let m;
        while ((m = anchorRegex.exec(svgContent)) !== null) {
          anchorTable[m[1]] = [parseFloat(m[2]), parseFloat(m[3])];
        }
        const textAnchorRegex = /<text[^>]*\sid="([^"]+)"[^>]*\sx="([^"]+)"[^>]*\sy="([^"]+)"[^>]*>/g;
        while ((m = textAnchorRegex.exec(svgContent)) !== null) {
          anchorTable[m[1]] = [parseFloat(m[2]), parseFloat(m[3])];
        }
      }
      variables.msd._viewBox = viewBox;
      variables.msd._anchors = anchorTable;
      const aspect = viewBox[2] && viewBox[3] ? (viewBox[2] / viewBox[3]) : 2;
      return `<div style="width:100%;height:100%;display:flex;justify-content:center;align-items:center;position:relative;aspect-ratio:${aspect};">${svgContent}</div>`;
    ]]]
  msd_svg_overlays: |
    [[[
      // The renderMsdOverlay helper now returns the markup and a list of animations to run.
      const { svgMarkup, animationsToRun } = window.cblcars.renderMsdOverlay({
        overlays: (() => {
          const slots = variables.msd.slots || {};
          return Object.values(slots).map(slot => slot.callout);
        })(),
        anchors: variables.msd._anchors,
        styleLayers: variables.msd.presets,
        hass,
        root: this.shadowRoot, // Pass shadowRoot for element queries
        viewBox: variables.msd._viewBox
      });

      // Schedule the animations to run after the card has rendered the SVG markup.
      if (animationsToRun.length > 0) {
        requestAnimationFrame(() => {
          animationsToRun.forEach(anim => window.cblcars.animateElement(anim));
        });
      }

      // Return only the SVG markup for the card to render.
      return svgMarkup;
    ]]]
styles:
  custom_fields:
    msd_svg_base:
      - width: 100%
      - height: 100%
      - position: absolute
      - top: 0
      - left: 0
      - z-index: 1
    msd_svg_overlays:
      - width: 100%
      - height: 100%
      - position: absolute
      - top: 0
      - left: 0
      - z-index: 1
